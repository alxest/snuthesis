\chapter{\;\;\;\;Module-Local Invariants and Specification Modules}
\label{sec:overview-modulelocal}

%
%% As a small case study,
%% we also verify \code{utod}, a handwritten assembly function casting long to double, whose correctness
%% against its specification is axiomatized in CompCert but not any more in \ccm{}
%% (\Cref{sec:overview-modulelocal:builtin}).
%

%% one has to assume that the static variable \texttt{x} resides in a private area
%% of the memory since it does not exist in the optimized code.
%% However, since the memory
%% injection of \cc{} requires that the private area of the memory should
%% be unchanged across any function call, it is contradictory to the
%% above optimization \texttt{UG}, where the private variable \texttt{x}
%% is updated across the call \texttt{g()}. Therefore, one cannot verify
%% \texttt{Unreadglob} using memory injection.

%% In order to verify \texttt{Unreadglob}, we define a new memory
%% relation, memory injection with module-local invariant $P$. The
%% relation is basically the same as memory injection except that instead
%% of requiring the private area to be unchanged across function calls,
%% we allow it to be modified as long as it satisfies the invariant $P$.
%% For example, to verify \texttt{Unreadglob}, we can use the trivial
%% invariant \texttt{Top} meaning that \texttt{x} can be modified
%% arbitrarily, which is sufficient because \texttt{x} is unread.

%% \youngju{not all, just injection}
%% All the verification techniques of \cc{} (and \ccc{}) impose the following strict requirement on
%% optimizations: $(i)$ in both the source and the target, memory is logically split into \emph{public}
%% and \emph{private} parts; $(ii)$ the public parts should be the same in the source and the target,
%% but the private parts may differ; $(iii)$ the private parts should not have been ``leaked'' in the
%% public parts; and $(iv)$ the private parts should not be changed during a (possibly unknown)
%% function call.  All CompCert optimizations---as well as most of the standard compiler
%% optimizations---indeed satisfy the above requirement.

%% However, some advanced optimizations do not satisfy the requirement, and thus are beyond the reach
%% of \cc{}'s verification techniques.  \Cref{fig:overview-modulelocal:compiler} presents a realistic
%% example of such optimizations.  In the left module, the function \code{f()} initially writes to the
%% static global variable \code{a} and then immediately reads from it.  The first transformation
%% performs constant propagation that replaces the read value with constant $1$.  Now \code{a} becomes
%% unread at all.  The second transformation performs \code{Unreadglob}, which removes the unread
%% static global variable \code{a} and all writes to it.  In the verification of the second
%% transformation, \code{a} should be private because it is removed in the target, but as opposed to
%% the requirement, the value of \code{a} in the source may be changed during the call to \code{g()},
%% which invokes \code{f()} that writes $1$ to \code{a}.

%% To verify \code{Unreadglob} and other optimizations that change private memory, we introduce
%% \emph{module-local invariants}: instead of requiring that private memory are not changed during a
%% function call, we allow private memory to change as far as it maintains the specified invariant of
%% the enclosing module.  This idea is embodied in our new memory relation, memory injection with
%% module-local invariants (on private memory).  As the module-local invariant in the verification of
%% \code{Unreadglob}, we require nothing on the value of the unread global variables (\eg{} \code{a})
%% because, after all, they are unread.

%% It is interesting to note that \code{Unreadglob} is provable in \ccx{}, but not because it supports
%% module-local invariants.  The reason is it disallows mutual recursion, thereby preventing the
%% complicated interaction among multiple modules as in \Cref{fig:overview-modulelocal:compiler}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
